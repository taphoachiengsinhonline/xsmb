// file: services/neuralNetworkService.js
const Result=require('../models/Result');const NNPrediction=require('../models/NNPrediction');const NNState=require('../models/NNState');const{DateTime}=require('luxon');
class NeuralNetwork{constructor(i,h,o){this.inputNodes=i;this.hiddenNodes=h;this.outputNodes=o;this.weights_ih=this.createMatrix(h,i);this.weights_ho=this.createMatrix(o,h);this.bias_h=this.createMatrix(h,1);this.bias_o=this.createMatrix(o,1);this.randomize();this.learningRate=0.1;}createMatrix(r,c){return Array(r).fill(0).map(()=>Array(c).fill(0));}randomize(){this.weights_ih=this.weights_ih.map(r=>r.map(()=>Math.random()*2-1));this.weights_ho=this.weights_ho.map(r=>r.map(()=>Math.random()*2-1));this.bias_h=this.bias_h.map(r=>r.map(()=>Math.random()*2-1));this.bias_o=this.bias_o.map(r=>r.map(()=>Math.random()*2-1));}sigmoid(x){return 1/(1+Math.exp(-x));}dsigmoid(y){return y*(1-y);}static fromJson(d){const n=new NeuralNetwork(d.inputNodes,d.hiddenNodes,d.outputNodes);n.weights_ih=d.weights_ih;n.weights_ho=d.weights_ho;n.bias_h=d.bias_h;n.bias_o=d.bias_o;n.learningRate=d.learningRate;return n;}predict(a){const i=this.arrayToMatrix(a);const h=this.multiply(this.weights_ih,i);h.forEach((r,i)=>r.forEach((_,j)=>h[i][j]+=this.bias_h[i][j]));h.forEach((r,i)=>r.forEach((v,j)=>h[i][j]=this.sigmoid(v)));const o=this.multiply(this.weights_ho,h);o.forEach((r,i)=>r.forEach((_,j)=>o[i][j]+=this.bias_o[i][j]));o.forEach((r,i)=>r.forEach((v,j)=>o[i][j]=this.sigmoid(v)));return this.matrixToArray(o);}train(a,t){const i=this.arrayToMatrix(a);const h=this.multiply(this.weights_ih,i);h.forEach((r,i)=>r.forEach((_,j)=>h[i][j]+=this.bias_h[i][j]));h.forEach((r,i)=>r.forEach((v,j)=>h[i][j]=this.sigmoid(v)));const s=this.multiply(this.weights_ho,h);s.forEach((r,i)=>r.forEach((_,j)=>s[i][j]+=this.bias_o[i][j]));s.forEach((r,i)=>r.forEach((v,j)=>s[i][j]=this.sigmoid(v)));const e=this.arrayToMatrix(t);const o=this.subtract(e,s);const g=s.map(r=>r.slice());g.forEach((r,i)=>r.forEach((v,j)=>g[i][j]=this.dsigmoid(v)));g.forEach((r,i)=>r.forEach((v,j)=>g[i][j]*=o[i][j]));g.forEach(r=>r.forEach((v,i)=>r[i]*=this.learningRate));const n=this.transpose(h);const d=this.multiply(g,n);this.weights_ho.forEach((r,i)=>r.forEach((_,j)=>this.weights_ho[i][j]+=d[i][j]));this.bias_o.forEach((r,i)=>r.forEach((_,j)=>this.bias_o[i][j]+=g[i][j]));const w=this.transpose(this.weights_ho);const _=this.multiply(w,o);const c=h.map(r=>r.slice());c.forEach((r,i)=>r.forEach((v,j)=>c[i][j]=this.dsigmoid(v)));c.forEach((r,i)=>r.forEach((v,j)=>c[i][j]*=_[i][j]));c.forEach(r=>r.forEach((v,i)=>r[i]*=this.learningRate));const p=this.transpose(i);const m=this.multiply(c,p);this.weights_ih.forEach((r,i)=>r.forEach((_,j)=>this.weights_ih[i][j]+=m[i][j]));this.bias_h.forEach((r,i)=>r.forEach((_,j)=>this.bias_h[i][j]+=c[i][j]));}arrayToMatrix(a){return a.map(e=>[e]);}matrixToArray(m){return m.flat();}transpose(m){return m[0].map((_,c)=>m.map(r=>r[c]));}multiply(a,b){return a.map((r,i)=>b[0].map((_,j)=>r.reduce((s,e,k)=>s+(e*b[k][j]),0)));}subtract(a,b){return a.map((r,i)=>r.map((v,j)=>v-b[i][j]));}}
const NN_MODEL_NAME='GDB_5_POS_PREDICTOR';const INPUT_NODES=135;const HIDDEN_NODES=64;const OUTPUT_NODES=50;
const PRIZE_ORDER=['ƒêB','G1','G2a','G2b','G3a','G3b','G3c','G3d','G3e','G3f','G4a','G4b','G4c','G4d','G5a','G5b','G5c','G5d','G5e','G5f','G6a','G6b','G6c','G7a','G7b','G7c','G7d'];
const prepareInput=(r)=>{const i=[];PRIZE_ORDER.forEach(p=>{const e=r.find(d=>d.giai===p);const s=String(e?.so||'0').padStart(5,'0');s.split('').forEach(d=>i.push(parseInt(d)/9));});return i;};
const prepareTarget=(g)=>{const t=Array(OUTPUT_NODES).fill(0.01);g.split('').forEach((d,i)=>{const n=parseInt(d);if(!isNaN(n)){t[i*10+n]=0.99;}});return t;};
const getNN=async()=>{const s=await NNState.findOne({modelName:NN_MODEL_NAME});return s?NeuralNetwork.fromJson(s.state):new NeuralNetwork(INPUT_NODES,HIDDEN_NODES,OUTPUT_NODES);};
const saveNN=async(n)=>{await NNState.findOneAndUpdate({modelName:NN_MODEL_NAME},{state:JSON.parse(JSON.stringify(n))},{upsert:true});};
const decodeOutput=(o)=>{const p={pos1:[],pos2:[],pos3:[],pos4:[],pos5:[]};for(let i=0;i<5;i++){const s=o.slice(i*10,(i+1)*10);const d=s.map((v,x)=>({digit:String(x),value:v})).sort((a,b)=>b.value-a.value).slice(0,5).map(x=>x.digit);p[`pos${i+1}`]=d;}return p;};
const runNNHistoricalTraining=async()=>{console.log('üîî [NN Service] Starting Historical Training...');const n=await getNN();const r=await Result.find().sort({'ngay':1}).lean();const g={};r.forEach(d=>{g[d.ngay]=g[d.ngay]||[];g[d.ngay].push(d);});const d=Object.keys(g).sort((a,b)=>a.localeCompare(b,'vi',{numeric:true}));let t=0;for(let i=1;i<d.length;i++){const p=d[i-1];const y=d[i];const a=prepareInput(g[p]||[]);const c=(g[y]||[]).find(e=>e.giai==='ƒêB');if(c?.so&&String(c.so).length>=5){const s=String(c.so).padStart(5,'0');const o=prepareTarget(s);n.train(a,o);t++;}}await saveNN(n);return{message:`AI ƒë√£ h·ªçc xong t·ª´ l·ªãch s·ª≠. ƒê√£ x·ª≠ l√Ω ${t} c·∫∑p d·ªØ li·ªáu.`};};
const runNNNextDayPrediction=async()=>{console.log('üîî [NN Service] Generating next day prediction...');const n=await getNN();const r=await Result.find().sort({'ngay':-1}).limit(27).lean();const g={};r.forEach(d=>{g[d.ngay]=g[d.ngay]||[];g[d.ngay].push(d);});const d=Object.keys(g).sort((a,b)=>a.localeCompare(b,'vi',{numeric:true}));const l=d[d.length-1];const a=prepareInput(g[l]||[]);const o=n.predict(a);const p=decodeOutput(o);const y=DateTime.fromFormat(l,'dd/MM/yyyy').plus({days:1}).toFormat('dd/MM/yyyy');await NNPrediction.findOneAndUpdate({ngayDuDoan:y},{ngayDuDoan:y,...p,danhDauDaSo:false},{upsert:true,new:true});return{message:`AI ƒë√£ t·∫°o d·ª± ƒëo√°n cho ng√†y ${y}.`,ngayDuDoan:y};};
const runNNLearning=async()=>{console.log('üîî [NN Service] Learning from new results...');const n=await getNN();const p=await NNPrediction.find({danhDauDaSo:false}).lean();if(!p.length)return{message:'Kh√¥ng c√≥ d·ª± ƒëo√°n m·ªõi n√†o ƒë·ªÉ h·ªçc.'};let t=0;for(const d of p){const r=await Result.findOne({ngay:d.ngayDuDoan,giai:'ƒêB'}).lean();if(r?.so&&String(r.so).length>=5){const s=String(r.so).padStart(5,'0');const o=prepareTarget(s);const e=await Result.find({ngay:DateTime.fromFormat(d.ngayDuDoan,'dd/MM/yyyy').minus({days:1}).toFormat('dd/MM/yyyy')}).lean();const a=prepareInput(e);n.train(a,o);t++;}await NNPrediction.updateMany({_id:{$in:p.map(x=>x._id)}},{danhDauDaSo:true});}await saveNN(n);return{message:`AI ƒë√£ h·ªçc xong. ƒê√£ x·ª≠ l√Ω ${t} k·∫øt qu·∫£ m·ªõi.`};};
module.exports={runNNHistoricalTraining,runNNNextDayPrediction,runNNLearning};
